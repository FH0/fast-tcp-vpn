# Fast-TCP-VPN 重构计划：支持所有 IP 数据包

## 背景

当前实现仅支持 TCP 协议数据包，需要重构为支持**所有 IP 数据包**（TCP/UDP/ICMP 等），通过将完整 IP 包封装到 RAW TCP 的 payload 中进行传输，并实现加密。

---

## 当前架构问题

### 1. Packet 结构限制
```rust
// src/infrastructure/packet/mod.rs:67-71
if ip_header.protocol != 6 {
    return Err(PacketError::NotTcp {
        protocol: ip_header.protocol,
    });
}
```
**问题**：只接受 TCP 协议（protocol=6），拒绝 UDP/ICMP 等。

### 2. Raw Socket 协议限制
```rust
// src/infrastructure/socket/raw_socket.rs:25
let fd = unsafe { libc::socket(libc::AF_INET, libc::SOCK_RAW, libc::IPPROTO_TCP) };
```
**问题**：使用 `IPPROTO_TCP`，只能收发 TCP 包。

### 3. 数据流处理
```rust
// server.rs / client.rs
let mut packet = match Packet::parse(&buffer[..len]) {
    Ok(p) => p,
    Err(_) => continue, // 非 TCP 包被丢弃
};
```
**问题**：非 TCP 包直接被跳过。

---

## 重构目标

```
┌─────────────────────────────────────────────────────────────────────┐
│                        原始 IP 数据包                                │
│  (TCP/UDP/ICMP/GRE/ESP 等任意协议)                                  │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         TUN 设备读取                                 │
│  读取完整的 IP 数据包（20+ 字节）                                    │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         加密封装                                     │
│  1. 对完整 IP 包进行加密                                             │
│  2. 构造传输用 TCP 包：IP头 + TCP头 + 加密后的原始IP包               │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      RAW TCP Socket 发送                            │
│  通过 Raw Socket 发送封装后的 TCP 包                                 │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
                         [网络传输]
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      RAW TCP Socket 接收                            │
│  接收封装的 TCP 包                                                   │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         解密解封装                                   │
│  1. 解析传输 TCP 包，提取 payload                                    │
│  2. 解密 payload，还原原始 IP 包                                     │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         TUN 设备写入                                 │
│  将还原的原始 IP 包写入 TUN                                          │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 重构步骤

### Phase 1: 基础设施层重构

#### 1.1 新增 IP 包解析（不限协议）
**文件**: `src/infrastructure/packet/ip.rs`

```rust
// 新增：仅解析 IP 头，不关心上层协议
impl IpHeader {
    /// 解析 IP 头，返回 (IP头, payload偏移量)
    pub fn parse_header_only(data: &[u8]) -> Result<(Self, usize), PacketError> {
        // 现有解析逻辑，但不检查 protocol
        // 返回 IP 头和 payload 起始位置
    }
}
```

#### 1.2 新增通用 IP 包结构
**文件**: `src/infrastructure/packet/mod.rs`

```rust
/// 通用 IP 数据包（支持任意协议）
#[derive(Debug, Clone)]
pub struct IpPacket {
    /// 原始字节数据
    pub raw: Vec<u8>,
    /// IP 头（已解析）
    pub ip_header: IpHeader,
    /// Payload 起始偏移
    pub payload_offset: usize,
}

impl IpPacket {
    /// 从原始字节解析
    pub fn parse(data: &[u8]) -> Result<Self, PacketError>;

    /// 获取 payload（IP 头之后的所有数据）
    pub fn payload(&self) -> &[u8];

    /// 转换为字节
    pub fn to_bytes(&self) -> Vec<u8>;
}
```

#### 1.3 新增传输包结构
**文件**: `src/infrastructure/packet/transport.rs`（新建）

```rust
/// VPN 传输包
///
/// 格式: [IP头(20B)] + [TCP头(20B+)] + [加密的原始IP包]
#[derive(Debug, Clone)]
pub struct TransportPacket {
    /// 外层 IP 头（传输用）
    pub outer_ip: IpHeader,
    /// 外层 TCP 头（传输用）
    pub outer_tcp: TcpHeader,
    /// 加密后的 payload（原始 IP 包）
    pub encrypted_payload: Vec<u8>,
}

impl TransportPacket {
    /// 创建传输包
    pub fn new(
        src_ip: Ipv4Addr,
        dst_ip: Ipv4Addr,
        src_port: u16,
        dst_port: u16,
        encrypted_payload: Vec<u8>,
    ) -> Self;

    /// 从原始字节解析
    pub fn parse(data: &[u8]) -> Result<Self, PacketError>;

    /// 序列化为字节
    pub fn to_bytes(&self) -> Vec<u8>;
}
```

---

### Phase 2: 封装/解封装服务

#### 2.1 封装服务
**文件**: `src/tunnel/encapsulation.rs`（新建）

```rust
/// 数据包封装服务
pub struct Encapsulator {
    /// 本地虚拟 IP
    local_vip: Ipv4Addr,
    /// 传输用源端口
    src_port: u16,
    /// 传输用目标端口
    dst_port: u16,
}

impl Encapsulator {
    /// 封装原始 IP 包
    ///
    /// 输入: 原始 IP 包字节
    /// 输出: 加密后的 payload（待放入 TransportPacket）
    pub fn encapsulate(&self, raw_ip_packet: &[u8], session: &mut Session)
        -> Result<Vec<u8>, EncapsulationError>;

    /// 解封装
    ///
    /// 输入: 加密的 payload
    /// 输出: 原始 IP 包字节
    pub fn decapsulate(&self, encrypted_payload: &[u8], session: &mut Session)
        -> Result<Vec<u8>, EncapsulationError>;
}
```

#### 2.2 协议头定义
**文件**: `src/tunnel/encapsulation.rs`

```rust
/// 封装协议头（放在加密 payload 前面）
///
/// 格式:
/// [0-1]   Magic: 0xFD 0xFD
/// [2]     Version: 0x01
/// [3]     Flags: 保留
/// [4-5]   Original Length: 原始 IP 包长度
/// [6-7]   Checksum: 头部校验
/// [8..]   Encrypted Original IP Packet
#[repr(C, packed)]
pub struct EncapsulationHeader {
    pub magic: [u8; 2],      // 0xFD, 0xFD
    pub version: u8,         // 0x01
    pub flags: u8,           // 保留
    pub original_len: u16,   // 原始包长度
    pub checksum: u16,       // 头部校验
}

impl EncapsulationHeader {
    pub const SIZE: usize = 8;
    pub const MAGIC: [u8; 2] = [0xFD, 0xFD];
}
```

---

### Phase 3: Server/Client 重构

#### 3.1 Server 数据流重构
**文件**: `src/server.rs`

```rust
// TUN -> Socket Worker 重构
fn tun_to_socket_worker(...) {
    let mut buffer = [0u8; 65535];

    while !shutdown.load(Ordering::Relaxed) {
        // 1. 从 TUN 读取原始 IP 包（任意协议）
        let len = match tun.read_with_timeout(&mut buffer, ...) {
            Ok(len) => len,
            Err(_) => continue,
        };

        // 2. 验证是 IP 包（检查版本号即可）
        if len < 20 || (buffer[0] >> 4) != 4 {
            continue; // 不是 IPv4
        }

        // 3. 提取目标 IP（用于路由）
        let dst_ip = Ipv4Addr::new(buffer[16], buffer[17], buffer[18], buffer[19]);

        // 4. 查找会话
        let session = match find_session_by_ip(dst_ip) {
            Some(s) => s,
            None => continue,
        };

        // 5. 封装 + 加密整个 IP 包
        let encrypted = encapsulator.encapsulate(&buffer[..len], session)?;

        // 6. 构造传输 TCP 包
        let transport = TransportPacket::new(
            local_ip,
            peer_ip,
            VPN_PORT,
            VPN_PORT,
            encrypted,
        );

        // 7. 发送
        socket.send_raw(&transport.to_bytes(), peer_ip)?;
    }
}

// Socket -> TUN Worker 重构
fn socket_to_tun_worker(...) {
    let mut buffer = [0u8; 65535];

    while !shutdown.load(Ordering::Relaxed) {
        // 1. 接收传输 TCP 包
        let len = match socket.receive_raw(&mut buffer, ...) {
            Ok(len) => len,
            Err(_) => continue,
        };

        // 2. 解析传输包
        let transport = match TransportPacket::parse(&buffer[..len]) {
            Ok(t) => t,
            Err(_) => continue,
        };

        // 3. 验证是 VPN 包（检查端口等）
        if !is_vpn_packet(&transport) {
            continue;
        }

        // 4. 查找/创建会话
        let session = get_or_create_session(...)?;

        // 5. 解密 + 解封装
        let original_ip = encapsulator.decapsulate(
            &transport.encrypted_payload,
            session
        )?;

        // 6. 写入 TUN（原始 IP 包）
        tun.write(&original_ip)?;
    }
}
```

#### 3.2 Client 数据流重构
**文件**: `src/client.rs`

与 Server 类似，但方向相反：
- TUN 读取 → 封装加密 → 发送到 Server
- 从 Server 接收 → 解密解封装 → 写入 TUN

---

### Phase 4: 配置扩展

#### 4.1 新增配置项
**文件**: `src/config.rs`

```rust
pub struct NetworkConfig {
    // 现有字段...

    /// VPN 传输端口
    pub vpn_port: u16,  // 默认 8443

    /// 是否启用加密
    pub encryption_enabled: bool,  // 默认 true
}
```

---

## 实施顺序

### 第一阶段：基础结构（预计 2-3 小时）
- [ ] 1.1 新增 `IpPacket` 结构
- [ ] 1.2 新增 `TransportPacket` 结构
- [ ] 1.3 新增 `EncapsulationHeader` 结构
- [ ] 1.4 单元测试：结构解析/序列化

### 第二阶段：封装服务（预计 2-3 小时）
- [ ] 2.1 实现 `Encapsulator` 封装逻辑
- [ ] 2.2 实现 `Encapsulator` 解封装逻辑
- [ ] 2.3 单元测试：封装/解封装往返

### 第三阶段：Server 重构（预计 3-4 小时）
- [ ] 3.1 重构 `tun_to_socket_worker`
- [ ] 3.2 重构 `socket_to_tun_worker`
- [ ] 3.3 更新会话查找逻辑
- [ ] 3.4 集成测试

### 第四阶段：Client 重构（预计 2-3 小时）
- [ ] 4.1 重构 `tun_to_socket_worker`
- [ ] 4.2 重构 `socket_to_tun_worker`
- [ ] 4.3 集成测试

### 第五阶段：端到端测试（预计 2 小时）
- [ ] 5.1 本地回环测试（TCP 流量）
- [ ] 5.2 本地回环测试（UDP 流量）
- [ ] 5.3 本地回环测试（ICMP ping）
- [ ] 5.4 混合流量测试

---

## 兼容性考虑

### 保留现有 Packet 结构
现有的 `Packet` 结构（IP+TCP）用于构造**传输层 TCP 包**，不需要删除。

### 新增结构关系
```
IpPacket          - 通用 IP 包（任意协议）
    ↓
Encapsulator      - 封装/加密
    ↓
TransportPacket   - 传输用 TCP 包（使用现有 Packet 构造）
```

---

## 风险与缓解

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| MTU 问题 | 封装后包过大导致分片 | 预留封装开销，动态调整内层 MTU |
| 性能下降 | 额外的封装/解封装开销 | 使用零拷贝优化，避免不必要的内存分配 |
| 加密开销 | CPU 使用率上升 | ChaCha20 已经很快，可考虑硬件加速 |

---

## 测试计划

### 单元测试
```rust
#[test]
fn test_ip_packet_parse_tcp() { ... }

#[test]
fn test_ip_packet_parse_udp() { ... }

#[test]
fn test_ip_packet_parse_icmp() { ... }

#[test]
fn test_encapsulate_decapsulate_roundtrip() { ... }

#[test]
fn test_transport_packet_roundtrip() { ... }
```

### 集成测试
```bash
# 测试 TCP
curl http://10.0.0.1/

# 测试 UDP
dig @10.0.0.1 example.com

# 测试 ICMP
ping 10.0.0.1
```

---

## 附录：数据包格式

### 传输包格式
```
+------------------+------------------+---------------------------+
|    IP Header     |   TCP Header     |     Encrypted Payload     |
|     (20 B)       |    (20+ B)       |                           |
+------------------+------------------+---------------------------+
                                      |
                                      v
                   +------------------+---------------------------+
                   | Encap Header (8B)|   Original IP Packet      |
                   +------------------+---------------------------+
```

### 封装头格式
```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Magic (0xFDFD)            |   Version     |    Flags      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Original Length        |           Checksum            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                   Encrypted Original IP Packet                |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
